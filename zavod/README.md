# Порядок исполнения и описание
***!DANGER. Критическое количество повторений слова "данные"***
### Изначально у нас есть word файлы. 
#### Некоторые вариации шаблона заполнения:
<p>
  <img width='400px' src='https://github.com/primera7790/ZAVOD_project/blob/master/zavod/data/images/word_table.PNG' alt='word_table'/>
  <img width='400px' src='https://github.com/primera7790/ZAVOD_project/blob/master/zavod/data/images/word_table_2.PNG' alt='word_table_2'/>
</p>

### Сторонними методами конвертируем в файлы формата .xlsx, после чего можно приступать.

## 1. Сбор данных
Файл: data_mining.py
- Некоторые вариации изначальных word файлов:
  
- Алгоритм проходится по каждому файлу отдельно и по ключевым закономерностям идентифицирует информацию;
- Найденные данные проходят первичную нормировку (обший формат даты, времени, фамилий с инициалами и т.д.);
- По возможности производим деление на логические блоки, формируя новые колонки;
  
#### Структура полученной таблицы:
<p>
  <img width='400px' src='https://github.com/primera7790/ZAVOD_project/blob/master/zavod/data/images/raw_data_info.PNG' alt='raw_data_info'/>
</p>
p.s. колонка "requester" на данном этапе остается пустой.

## 2. Подготовка данных
Файл: data_preparation.py
- Находим аномальные и некорректные значения, исправляем;
- Избавляемся от строк не содержащих полезной инормации (условно пустых);
- Приводим имеющиеся данные к конечному виду.

## 3. Формируем колонку "requester" при помощи метода **kNN**
Файл: kNN_optimized.py
- Используем **kNN**, метод ближайшего соседа:
  - Формируем список возможных заявителей (тут пришлось вручную потрудиться);
  - Задаем алгоритм подсчета максимального количества буквенных комбинаций (поле для экспериментов);
  - Применяем алгоритм к текстовой колонке "info", для каждой строки присваиваем заявителя из соответствующего списка;
- Во избежание определения ложных фамилий, появляющихся в тексте после указания искомой, ограничил количество символов в зависимости от исходного размера;
- Также в директории "archive" сохранен файл с первоначальным вариантом исполнения. В дальнейшем, переписав код, удалось сократить время исполнения примерно в 20 раз.
  
#### Схематичная работа kNN:
<p>
  <img width='800px' src='https://github.com/primera7790/ZAVOD_project/blob/master/zavod/data/images/knn.PNG' alt='knn'/>
</p>

## 4. Корректировка данных
Файл: hide_correction.py
#### Остается ряд проблемных мест, которые приходится решать "заплатками":
- фамилии часто указываются без инициалов, что поднимает проблему однофамильцев;
- ошибки в написании фамилий (если для колонки "requester" и kNN в частности это не является особой проблемой, то для колонок "master_day" и "master_night" это критично,
т.к. заполняем мы их непосредственно из исходной таблицы еще на стадии сбора данных.
#### Выявляем огрехи и правим, где-то точечно, где-то по закономерностям.

## 5. Формируем колонку "manufacture" при помощи алгоритма **Decision Tree**

### 5.1. Подготавливаем данные
Файл: feature_engineering.py
- Составляем:
   - список целевых признаков, т.е. всех производств на заводе;
   - [список признаков, описывающих каждый объект](https://github.com/primera7790/ZAVOD_project/blob/master/zavod/data/total_data/obj_features.csv);
   - перечень известных наименований объектов;
- Формируем таблицу объект-признак с целевыми значениями (для обучения модели):
   - Отсекаем лишние повторяющиеся приписки (вроде об., отд.);
   - Присваиваем каждому объекту соответствующее ему производство (задаем целевой признак);
   - Сплитуем текст объектов по пробелу;
   - Cоставляем перечень получившихся элементов списка с сохранением привязки к производству;
   - Переводим получившиевся данные в признаковое пространство
- Составляем перечень уникальных записей в колонке "object";
- Формируем таблицу объект-признак по каждому объекту из табличных данных (для дальнейшего предсказания производств)
  
### 5.1. Классифицируем объекты по производствам
Файл: feature_engineering.py

 


