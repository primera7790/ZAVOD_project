# Порядок исполнения и описание
***!DANGER. Непозволительно зашкаливающие количество слова "данные"***
## 1. Сбор данных
Файл: data_mining.py
- Алгоритм проходится по каждому файлу отдельно и по ключевым закономерностям идентифицирует информацию;
- Найденные данные проходят первичную нормировку (обший формат даты, времени, фамилий с инициалами и т.д.);
- По возможности производим деление на логические блоки, формируя новые колонки;
- Структура полученной таблицы:
<pre>
   df_total = pd.DataFrame(columns=['date_day', 'date_night', 'object', 'installation', 'start_time', 'end_time',
                                    'master_day', 'master_night', 'info', 'requester', 'max_power', 'min_power',
                                    'power_per_24_hours', 'power_supply_scheme', 'file_name']) 
  
   p.s. колонка "requester" на данном этапе остается пустой.
</pre>
   
## 2. Подготовка данных
Файл: data_preparation.py
- Находим аномальные и некорректные значения, исправляем;
- Избавляемся от строк не содержащих полезной инормации (условно пустых);
- Приводим имеющиеся данные к конечному виду.

## 3. Формируем колонку "requester"
Файл: kNN_optimized.py
- Используя метод ближайшего соседа:
  - Формируем список возможных заявителей (тут пришлось вручную потрудиться);
  - Задаем алгоритм подсчета максимального количества буквенных комбинаций (поле для экспериментов);
  - Применяем алгоритм к текстовой колонке "info", для каждой строки присваиваем заявителя из соответствующего списка;
  - Во избежание определения ложных фамилий, появляющихся в тексте после указания искомой, ограничил количество символов в зависимости от исходного размера;
  - Также в директории "archive" сохранен файл с первоначальным вариантом исполнения. В дальнейшем, переписав код, удалось сократить время исполнения примерно в 20 раз.
 

однофамильцы
